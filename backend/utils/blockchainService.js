import { ethers } from 'ethers';
import fs from 'fs';
import path from 'path';
import crypto from 'crypto';
import dotenv from 'dotenv';
import FarmerDocument from '../models/FarmerDocument.js';
import User from '../models/userModel.js';

dotenv.config();

// Load contract ABI and address
const getContractInfo = () => {
  try {
    // Read from the test data generated by the test-two-farmers.js script
    const testDataPath = path.join(process.cwd(), '../smart-contracts/deployments/FarmerCertification.json');
    if (!fs.existsSync(testDataPath)) {
      throw new Error('Contract deployment info not found');
    }
    
    const contractInfo = JSON.parse(fs.readFileSync(testDataPath, 'utf8'));
    return contractInfo;
  } catch (error) {
    console.error('Error loading contract information:', error);
    throw new Error('Failed to load contract information');
  }
};

// Create a provider and wallet instance
const getProviderAndWallet = () => {
  // Use the Hedera Testnet RPC URL from .env
  const provider = new ethers.providers.JsonRpcProvider(process.env.HEDERA_RPC_URL);
  
  // Use the admin private key from .env
  const wallet = new ethers.Wallet(process.env.ADMIN_PRIVATE_KEY, provider);
  
  return { provider, wallet };
};

// Get contract instance
export const getContract = () => {
  const contractInfo = getContractInfo();
  const { wallet } = getProviderAndWallet();
  
  return new ethers.Contract(
    contractInfo.address,
    contractInfo.abi,
    wallet
  );
};

// Issue a certificate on the blockchain
export const verifyAndIssueCertificate = async (farmerId) => {
  try {
    // First fetch the farmer document to get both hashes
    const farmerDoc = await FarmerDocument.findOne({ farmerId });
    
    if (!farmerDoc || !farmerDoc.documents) {
      throw new Error('Farmer document not found');
    }
    
    // Check if both documents exist and are verified
    if (!farmerDoc.documents.aadhaar || 
        !farmerDoc.documents.certificate || 
        farmerDoc.documents.aadhaar.status !== 'verified' || 
        farmerDoc.documents.certificate.status !== 'verified') {
      throw new Error('Both Aadhaar and certificate must be verified before issuing a blockchain certificate');
    }
    
    const contract = getContract();
    
    // Generate a unique certificate ID
    const certificateId = `CERT-${farmerId}-${Date.now()}`;
    
    // Get farmer details from MongoDB
    const farmer = await getFarmerDetails(farmerId);
    
    // Use the actual document hashes from the verified documents
    const aadharHash = '0x' + farmerDoc.documents.aadhaar.fileHash;
    const certificateHash = '0x' + farmerDoc.documents.certificate.fileHash;
    
    console.log(`Issuing certificate with Aadhaar hash: ${aadharHash.substring(0, 18)}...`);
    console.log(`and certificate hash: ${certificateHash.substring(0, 18)}...`);
    
    // Issue the certificate on blockchain
    const transaction = await contract.issueCertificate(
      certificateId,
      farmerId.toString(),
      farmer.name,
      aadharHash,
      certificateHash
    );
    
    console.log(`Certificate issuance transaction submitted: ${transaction.hash}`);
    
    // Wait for transaction to be mined
    const receipt = await transaction.wait();
    console.log(`Certificate issued in block ${receipt.blockNumber}`);
    
    // Return certificate details
    return {
      certificateId,
      farmerId,
      farmerName: farmer.name,
      transactionHash: transaction.hash,
      blockNumber: receipt.blockNumber,
      timestamp: Date.now(),
      aadharHash: aadharHash.substring(0, 18) + '...',
      certificateHash: certificateHash.substring(0, 18) + '...'
    };
  } catch (error) {
    console.error('Error issuing certificate on blockchain:', error);
    throw new Error(`Blockchain error: ${error.message}`);
  }
};

// Verify a certificate on the blockchain
export const verifyCertificate = async (certificateId) => {
  try {
    const contract = getContract();
    
    // Call the contract's verification function
    const verification = await contract.verifyCertificateById(certificateId);
    
    // Return the verification result
    return {
      isValid: verification.isValid,
      farmerId: verification.farmerId,
      farmerName: verification.farmerName,
      expiryDate: new Date(verification.expiryDate.toNumber() * 1000).toISOString(),
      isExpired: verification.expiryDate.toNumber() * 1000 < Date.now()
    };
  } catch (error) {
    console.error('Error verifying certificate:', error);
    throw new Error(`Blockchain verification error: ${error.message}`);
  }
};

// Function to get farmer details from MongoDB
const getFarmerDetails = async (farmerId) => {
  try {
    const farmer = await User.findById(farmerId);
    if (!farmer) {
      throw new Error(`Farmer with ID ${farmerId} not found`);
    }
    return {
      id: farmer._id.toString(),
      name: farmer.name || `Farmer ${farmer._id.toString().substring(0, 6)}`, // Use name or a placeholder
      email: farmer.email
    };
  } catch (error) {
    console.error('Error fetching farmer details:', error);
    // Return a placeholder if we couldn't get the actual details
    return {
      id: farmerId.toString(),
      name: `Farmer ${farmerId.toString().substring(0, 6)}`,
    };
  }
};
